{"name":"Goose","tagline":"A Go library for Elasticsearch","body":"![logo](http://go-tsunami.com/assets/images/gooseLogo.png)\r\n\r\ngoose, a golang API for Elastic Search\r\n======================================\r\n\r\ngoose is an attempt to write a library to easily use the power of elastic search within a golang program.\r\nThe coverage of elastic functionalities is currently quite low but allows one to use the basics:\r\n- CRUD operations on indexes\r\n- Add mapping\r\n- Search\r\n- Sort\r\n\r\nIt takes advantages of golang interface concept to offer flexibility. A really cool feature is the `QueryBuilder`!\r\n\r\nRequirements\r\n------------\r\n\r\ngoose requires what it exists for: golang and elastic search.\r\nThe current version of goose works with golang 1.3 and elastic search 1.x\r\n\r\nInstallation\r\n------------\r\n\r\nUse `go get`:\r\n```go\r\ngo get github.com/gotsunami/goose\r\n```\r\n\r\nPowerful query builders!\r\n------------------------\r\n\r\nES formalism is powerful but quite uneasy to learn or to write as it is not very human readable.\r\n\r\nThe idea of query builder is to create the ES requests without having to actually write the json content of the request. In addition, some request need PUSH, other need PUT or DELETE, query builders know which one to use.\r\n\r\nThere are two kinds of builders in goose right now detailed in the following sections:\r\n- Mapping builders\r\n- Search builders\r\n\r\nElasticSearch\r\n-------------\r\n\r\nAs suggested in elastic search documentation, one should open only one instance of a client to communicate with the elastic search server. In goose, this client is the type `ElasticSearch`. It will do most of the job.\r\n\r\nIn goose, an instance corresponds to an index so when you create an `ElasticSearch`, you must specify the index. You can create an instance as a global variable like that:\r\n\r\n```go\r\nu, err := url.Parse(\"http://localhost:9200/my_index/\")\r\nes, err := goose.NewElasticSearch(u)\r\n```\r\n\r\nNote: each time `es` appears in the following document, it refers to the global instance of `ElasticSearch`\r\n\r\nElasticObject\r\n-------------\r\n\r\ngoose also uses an interface called `ElasticObject` for most API calls.\r\nThis interface must define a function called `Key()` that can compute an unique key for each instance.\r\nOnce your data structure implements `ElasticObject`, you are almost done! (well, almost I said...)\r\n\r\nFor instance:\r\n\r\n```go\r\ntype HQ struct {\r\n    Company  string `json:\"company\"`\r\n    Country  uint64 `json:\"country\"`\r\n    Location goose.Location `json:\"location\"`\r\n}\r\n\r\nfunc (hq *HQ) Key() string {\r\n    return fmt.Sprintf(\"%s_%d\", hq.Company, hq.Country)\r\n}\r\n```\r\n\r\nIndexes\r\n-------\r\n\r\nFirst things first, basic index operations. As a `ElasicSearch` instance matches an unique index, it is pretty straightforward:\r\n```go\r\nerr := es.CreateIndex()\r\nerr = es.CreateIndexIfNeeded()\r\nerr = es.OpenIndex()\r\nerr = es.CloseIndex()\r\nerr = es.DeleteIndex()\r\n```\r\n\r\nRefer to elastic search documentation to know more about indexes: http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/indices.html\r\n\r\nCRUD\r\n----\r\n\r\nThe `ElasticSearch` provides a set of functions for CRUD operations:\r\n\r\n```go\r\nhq := &HQ{Company:\"go-tsunami\", Country:33, Location:goose.Location{48.865618, 2.370985}}\r\nerr := es.Insert(hq)\r\nfound, err := es.Get(hq)\r\nhq.Company = \"Go Tsunami\"\r\nerr = es.Update(hq)\r\nerr = es.Delete(hq)\r\n```\r\n\r\nAn additional  `DeleteByQuery` is available to delete a set of objects.\r\n\r\nTODO: `UpdateByQuery`\r\n\r\nRefer to elastic search documentation for more information or to contribute: http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/docs.html#docs\r\n\r\nMapping\r\n-------\r\n\r\nCurrently handled mapping types are:\r\n- date\r\n- geo_point\r\n- string\r\n- long\r\n\r\nHere is an exemple of how to use a `MappingBuilder` to add a `geo_point` mapping to field Location of type HQ:\r\n\r\n```go\r\nmb := NewMappingBuilder().AddMapping(\"location\", TYPE_GEOPOINT)\r\nerr := es.SetMapping(&HQ{}, mb)\r\n```\r\n\r\nReferences:\r\nhttp://www.elasticsearch.org/guide/en/elasticsearch/reference/current/indices-put-mapping.html\r\n\r\nSearch\r\n------\r\n\r\nAt last, here we are, ready to make search queries!\r\n\r\nThe query builder currently handles the following search criteria:\r\n- geo_distance\r\n- geo_boundingbox\r\n- geo_polygon\r\n- should\r\n- must\r\n- facetting\r\n- fuzzy search\r\n- range\r\n- greater or lower than\r\n\r\nHere is an example:\r\n```go\r\nqb = qb.SetTerm(\"Company\", \"Go Tsunami\")\r\nqb = qb.AddGeoBoundingBox(\"location\",\r\n    goose.Location{-180, 90},\r\n    goose.Location{180, -90})\r\n\r\ntotal, err := es.Count(&HQ{})\r\nif err != nil {\r\n    return nil, err\r\n}\r\n\r\nqb.Size = total\r\nresults, err := es.Search(&HQ{}, qb)\r\nif err != nil {\r\n    return nil, err\r\n}\r\n\r\nfor _, match := range results.Hits.Data {\r\n    hq, ok := match.Object.(*HQ)\r\n    if !ok {\r\n        return ids, errors.New(\r\n            fmt.Sprintf(\"ElasticSearch returned an invalid object (%v)\", match.Src))\r\n    }\r\n    fmt.Println(\"An HQ was found for Go Tsunami at GPS coordinates %v\", hq.Location)\r\n}\r\n```\r\n\r\nMore\r\n----\r\n\r\nSource code contains a lot of comments, especially in the query builder. You can find a full example of a dumb application in example/hq.go.\r\n\r\nYou can play with it:\r\n```go\r\ngo build example/hq.go\r\n./hq\r\n```\r\n\r\nIf you want to run queries on the created index, you can find it at `http://localhost:9200/hq/main__hq`\r\n\r\nContribute\r\n----------\r\n\r\ngoose is an ongoing work, we'd be pleased to review any pull request!  \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}